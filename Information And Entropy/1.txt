Алгоритм Шеннона-Фано — один з перших алгоритмів стиснення, який сформулювали американські вчені Шеннон і Фано. Даний метод стиснення має велику схожість з алгоритмом Хаффмана, який з'явився на кілька років пізніше. Алгоритм використовує коди змінної довжини: символ, який часто зустрічається, кодується кодом меншої довжини, а той що рідше зустрічається — кодом більшої довжини. Коди Шеннона-Фано префіксні, тобто ніяке кодове слово не є префіксом будь-якого іншого. Ця властивість дозволяє однозначно декодувати будь-яку послідовність кодових слів.


Зміст
1	Основні відомості
2	Основні етапи
3	Алгоритм обчислення кодів Шеннона-Фано
3.1	Приклад кодового дерева
4	Література
Основні відомості
Кодування Шеннона-Фано (англ. Shannon-Fano coding) — алгоритм префіксного неоднорідного кодування. Відноситься до ймовірнісних методів стиснення (точніше, методів контекстного моделювання нульового порядку). Подібно алгоритму Хаффмана, алгоритм Шеннона-Фано використовує надмірність повідомлення, укладених в неоднорідному розподілі частот його символів (первинного) алфавіту, тобто замінює коди символів, які частіше використовуються, короткими двійковими послідовностями, а коди більш рідкісних символів — більш довгими двійковими послідовностями.

Алгоритм був незалежно один від одного розроблений Шенноном (публікація «Математична теорія зв'язку», 1948 рік) і, пізніше, Фано (опубліковано як технічний звіт).

Основні етапи
Символи первинного алфавіту m1 виписують в порядку зменшення ймовірностей.
Символи отриманого алфавіту ділять на дві частини, сумарні ймовірності символів яких максимально близькі один одному.
У префіксному коді для першої частини алфавіту присвоюється двійкова цифра «0», другої частини — «1».
Отримані частини рекурсивно діляться і їх частинам призначаються відповідні двійкові цифри в префіксному коді.
Коли розмір підалфавіту стає рівним нулю або одиниці, то наступне подовження префіксних коду для відповідних йому символів первинного алфавіту не відбувається, таким чином, алгоритм привласнює різним символам префіксні коди різної довжини. На кроці ділення алфавіту існує неоднозначність, так як різниця сумарних ймовірностей {\displaystyle p_{0}-p_{1}}{\displaystyle p_{0}-p_{1}} може бути однакова для двох варіантів поділу (враховуючи, що всі символи первинного алфавіту мають ймовірність більше нуля).

Алгоритм обчислення кодів Шеннона-Фано

Кодування Шеннона-Фано
Код Шеннона-Фано будується за допомогою дерева. Побудова цього дерева починається від кореня. Вся множина кодованих елементів відповідає кореню дерева (вершині першого рівня). Воно розбивається на дві підмножини з приблизно однаковими сумарними ймовірностями. Ці підмножини відповідають двом вершинам другого рівня, які з'єднуються з коренем. Далі кожна з цих підмножин розбивається на дві підмножини з приблизно однаковими сумарними ймовірностями. Їм відповідають вершини третього рівня. Якщо підмножина містить єдиний елемент, то йому відповідає кінцева вершина кодового дерева; така підмножина розбиттю не підлягає. Подібним чином поступаємо до тих пір, поки не отримаємо всі кінцеві вершини. Гілки кодового дерева розмічаємо символами 1 і 0, як у випадку коду Хаффмана.

При побудові коду Шеннона-Фано розбиття множини елементів може бути обрано, взагалі кажучи, декількома способами. Вибір розбиття на рівні n може погіршити варіанти розбиття на наступному рівні (n + 1) і призвести до неоптимальності коду в цілому. Іншими словами, оптимальна поведінка на кожному кроці шляху ще не гарантує оптимальності всієї сукупності дій. Тому код Шеннона-Фано не є оптимальним в загальному сенсі, хоча і дає оптимальні результати при деяких розподілах імовірностей. Для одного і того ж розподілу ймовірностей можна побудувати, взагалі кажучи, кілька кодів Шеннона-Фано, і всі вони можуть дати різні результати. Якщо побудувати всі можливі коди Шеннона-Фано для даного розподілу ймовірностей, то серед них будуть знаходитися і всі коди Хаффмана, тобто оптимальні коди.